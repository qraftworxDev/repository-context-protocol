---
description:
globs:
alwaysApply: true
---
---
description: Defines mandatory usage of RepoContext MCP tools for comprehensive codebase analysis and semantic understanding across all code-related tasks.
author: AI Assistant
version: 1.0
tags: ["repocontext", "semantic-analysis", "code-understanding", "mcp-tools", "core-behavior"]
globs: ["**/*.go", "**/*.py", "**/*.ts", "**/*.tsx", "**/*.js", "**/*.jsx", "*"]
---
# RepoContext Semantic Analysis Protocol

I MUST use RepoContext MCP tools to deeply understand any codebase before providing analysis, suggestions, or modifications.
This semantic analysis capability is essential for accurate, context-aware responses about code structure, relationships, and functionality.
I MUST run all of the commands from the project root directory.
I MUST always pass the repo root full path as a path parameter to ALL tool calls.

## Repository Analysis Workflow

Every code-related interaction follows this mandatory workflow:

```mermaid
flowchart TD
    Start[Code Task] --> Check{Repository Initialized?}

    Check -->|No| Init[Initialize Repository]
    Init --> Build[Build Semantic Index]

    Check -->|Yes| Status[Check Repository Status]
    Status --> Fresh{Index Current?}
    Fresh -->|No| Rebuild[Rebuild Index]
    Fresh -->|Yes| Analyze[Semantic Analysis]

    Build --> Analyze
    Rebuild --> Analyze

    Analyze --> Query[Query Specific Context]
    Query --> Respond[Provide Informed Response]
```

## Core RepoContext Tools

### Repository Management (Required First)
1. **initialize_repository**
   - Initialize semantic analysis capability
   - Creates `.repocontext` directory structure
   - Required before any analysis

2. **get_repository_status**
   - Check initialization and indexing status
   - Verify semantic index is current
   - Get repository statistics and metadata

3. **build_index**
   - Build/rebuild comprehensive semantic index
   - Process all supported languages (Go, Python, TypeScript)
   - Generate function, type, variable, and call relationship data

### Semantic Query Tools (Use Based on Need)
4. **query_by_name**
   - Find specific functions, types, or variables by name
   - Supports exact matches and pattern matching
   - Get detailed context and signatures

5. **query_by_pattern**
   - Search using regex patterns
   - Find entities matching specific naming conventions
   - Discover related code patterns

6. **get_function_context**
   - Deep analysis of specific functions
   - Include parameters, return types, documentation
   - Get usage examples and related functions

7. **get_type_context**
   - Comprehensive type analysis
   - Include fields, methods, and usage patterns
   - Understand type relationships and implementations

### Advanced Analysis Tools
8. **get_call_graph**
   - Analyze function call relationships
   - Understand caller/callee dependencies
   - Control depth and external call inclusion

9. **find_dependencies**
   - Discover entity dependencies (callers/callees)
   - Analyze both function and type relationships
   - Get comprehensive dependency mapping

## Mandatory Usage Patterns

### Before Code Analysis
```mermaid
flowchart TD
    Task[Code Analysis Task] --> Init[Check/Initialize Repository]
    Init --> Index[Ensure Current Index]
    Index --> Context[Query Relevant Context]
    Context --> Analysis[Perform Analysis]
```

ALWAYS:
1. **Initialize**: Use `initialize_repository` if not already done
2. **Verify**: Use `get_repository_status` to check index status
3. **Index**: Use `build_index` if index is stale or missing
4. **Query**: Use relevant query tools before analysis

### During Code Understanding
- **Function Analysis**: Use `get_function_context` for detailed function understanding
- **Type Exploration**: Use `get_type_context` for comprehensive type analysis
- **Relationship Mapping**: Use `get_call_graph` and `find_dependencies` for understanding connections
- **Pattern Discovery**: Use `query_by_pattern` for finding related code patterns
- **Entity Location**: Use `query_by_name` for finding specific entities

### Response Enhancement Strategy
1. **Context First**: Always gather semantic context before making statements about code
2. **Relationship Aware**: Use call graph analysis to understand impact of changes
3. **Type Informed**: Use type context to provide accurate type-related advice
4. **Pattern Conscious**: Use pattern queries to find similar implementations
5. **Dependency Aware**: Use dependency analysis to understand ripple effects

## Tool Selection Guidelines

### For Code Questions
- **"What does function X do?"** → `get_function_context`
- **"How is type Y used?"** → `get_type_context` with `include_usage=true`
- **"What calls function X?"** → `find_dependencies` with `dependency_type=callers`
- **"Find all functions like pattern"** → `query_by_pattern`

### For Code Changes
- **Before modifying function** → `get_call_graph` to understand impact
- **Before changing type** → `get_type_context` + `find_dependencies`
- **Before refactoring** → Multiple tools to map all relationships

### For Architecture Understanding
- **System overview** → `get_repository_status` + broad `query_by_pattern`
- **Module relationships** → `get_call_graph` with external calls
- **API surface analysis** → `query_by_pattern` for exported entities

## Quality Standards
### Semantic Analysis Requirements
- **Complete Context**: Always gather full context before analysis
- **Relationship Awareness**: Understand connections between code entities
- **Type Accuracy**: Use type context for precise type-related responses
- **Impact Assessment**: Use call graphs to understand change implications
- **Pattern Recognition**: Use pattern queries to identify coding conventions

### Response Standards
- **Context-Informed**: Base all responses on actual semantic analysis
- **Relationship-Aware**: Mention relevant connections and dependencies
- **Precise**: Use exact function signatures and type definitions from analysis
- **Comprehensive**: Include related entities and usage patterns when relevant

## Error Handling

If RepoContext tools fail:
1. **Initialization Issues**: Verify directory permissions and Go installation
2. **Index Building Failures**: Check for syntax errors in code files
3. **Query Failures**: Verify entity names and patterns are correct
4. **Performance Issues**: Use `max_tokens` parameters to limit response size

## Integration with Other Tools

RepoContext analysis should be combined with:
- **File reading** for implementation details
- **Grep search** for specific code patterns
- **Web search** for external documentation
- **Git analysis** for change history context

**CRITICAL**: RepoContext semantic analysis is not optional for code-related tasks. It provides the foundation for accurate, contextual, and relationship-aware code assistance. Always use these tools to enrich understanding before providing code-related responses.
